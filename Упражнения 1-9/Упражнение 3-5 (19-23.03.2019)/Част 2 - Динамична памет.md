## Динамична памет

> Не забравяйте да си delete-вате паметта преди края на програмата!

### Задача 1.
Напишете функция copy_of(const double* arr, int size), която приема указател към масив от числа и неговия размер,
и връща указател към копие на масива, заделено в динамичната памет

Защо arr е const?

### Задача 2.
Напишете функция copy_of(const char* str), която приема указател към символен низ и връща указател към копие на низа,
заделено в динамичната памет

Защо str е const? Защо този път няма size?

### Задача 3.
Напишете функция find_capitals(const char* str), която връща символен низ, съдържащ само главните букви в str.
Заделете максимално малко количество памет

### Задача 4.
Напишете функция concat(const char* a, const char* b), която връща конкатенацията на два символни низа

### Задача 5.
Направете така, че символните низове в Product и User да са в динамичната памет.

- Конструкторите по подразбиране, също като преди, трябва да създават празни, но валидни низове, с '\0'
- При промяна на низ извън конструкторите (в сетърите и оператора=),
паметта за него трябва да се изтрие и да се задели памет за новия низ
- В конструкторите трябва да се заделя памет, но няма нужда от триене

### Задача 6.
Напишете деструктор за Product и деструктор за User

> Деструкторът е специален метод на клас, който за всеки обект се изпълнява точно веднъж - когато
обектът бъде унищожен (от там идва и името destructor, което не случайно се римува с constructor).<br>
Деструкторът по правило трябва да прави само едно - да освободи всичката динамична памет<br>
За разлика от конструкторите, които може да са много, деструкторът е само един в класа и се пише така:

    class Product {
        // ...

        ~Product() {
          // ...
        }
    }

Какво ще се случи, ако оставим някой класовете без деструктор? Защо не напишем деструктори и за Cost и Store?
