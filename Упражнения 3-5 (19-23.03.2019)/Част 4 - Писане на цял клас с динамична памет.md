## Цял клас с динамична памет

### Задача 1.
Да се напише клас Студент със следните данни:

- име - символен низ с произволна дължина
- ЕГН - символен низ с 10 символа
- факултетен номер - цяло число
- оценки - масив от дробни числа с произволна дължина

За класа напишете:

- голяма четворка (или още канонично представяне или канонични методи):
  - конструктор по подразбиране - да прави всичко 0 или празен масив
  - конструктор за копиране
  - оператор =
  - деструктор
- конструктор с три параметъра - за името, ЕГН-то и факултетния номер
- гетъри за всичко
- сетъри за името, ЕГН-то и факултетния номер
- метод, който добавя оценка - да може да се добавят колкото си искаме оценки
- метод, който връща средния успех - сумата от оценките, разделена на броя им

Част от задачата е да:
- решите какви да са член-данните, трябват ли ви допълнителни член-данни и какви
- пишете const и & навсякъде, където е удачно

### Задача 2.
Напишете клас String, представящ символен низ, с който да работим лесно така:

    // Да можем да го създаваме с конструктор по подразбиране, чрез обикновен символен низ и чрез друг String
    String a;
    String b("oop");
    String c(b);
    
    // Да можем да видим колко е дължината му и да го принтираме
    cout << a.length();         // 0
    cout << b.length();         // 3
    b.print();                  // oop
    c.print();                  // oop

    // Да можем да го преобразуваме в обикновен низ
    char subjects[100] = "up, ";
    strcpy(subjects, b.to_char_array());
    cout << subjects;           // up, oop
    
    // Да можем да присвоим на стринга обикновен низ
    a = "Chestita";
    b = "prolet";
    
    // Да можем да добавяме един символ, обикновен низ или друг String към края
    c += "epi";
    c += '!';
    c.print();                  // oopepi!
    
    // Да имаме събиране със смисъл на конкатенация
    c = a + b;
    c.print();                  // Chestita prolet!
    
    // += да връща подходяща стойност
    (a += "prolet").print();    // Chestita prolet
    
    // Да можем да достъпваме символите чрез [] - това ще е възможно, ако напишем operator[]
    a = "Sirene";
    cout << a[0];               // S
    cout << a[1];               // i
    
    // Да можем да променяме символ чрез []
    a[3] = 'i';
    a.print();                  // Sirine
    
    // Все пак [] да работи и за константи
    // (Упътване: Трябва да се напишат две версии на оператора)
    cout << String("FMI")[1];   // M
    
    // Да можем да въвеждаме низа от клавиатурата - трябва да можем да прочетем неограничен брой символи
    // (Упътване: Ще трябва да ги четем и записваме в разширяваща се памет символ по символ)
    a.read();
    
    // Да можем да принтираме низа със cout
    // (Упътване: cout всъщност е обект - от вградения в С++ клас ostream, а << е оператор)
    cout << a;
    
    // Да можем да четем низа със cin
    // (Упътване: cin е обект от вградения в С++ клас istream, >> също е оператор)
    cin >> a;
    
    // Да можем да пишем << и >> във верижка
    cout << a << b;
    cin >> a >> b;

Част от задачата е да:
- решите какви член-данни ви трябват
- решите какви типове аргументи да приемат методите и какви типове да връщат
- решите кои методи да са const
- напишете голяма четворка

### Задача 3.
Напишете клас Matrix, представляващ матрица от int-ове с произволни размери, с която да можем да работим така:

    // По подразбиране да има 0 реда и 0 колони
    Matrix m;
    cout << m.number_of_rows() << ' ' << m.number_of_cols();   // 0 0
    
    // Да може да се зададат размери при създаването (всички елементи на матрицата да са 0 в началото)
    m = Matrix(3, 4);
    cout << m.number_of_rows() << ' ' << m.number_of_cols();   // 3 4

    // Да може да се добавят и махат редове и колони
    m.add_rows(2);
    m.remove_cols(3);
    cout << m.number_of_rows() << ' ' << m.number_of_cols();   // 5 1
    
    // Да може да се зададат стойности на елементите при създаването, които да се подадат с масив
    // (Ако в масива има твърде много елементи, последните да се игнорират)
    int numbers[9] = {
        11, 12, 13,
        14, 15, 16,
        17, 18, 19
    };
    m = Matrix(3, 3, numbers);

    // Елементите да може да се достъпват и променят по стандартния начин
    m[1][2] = 42;
    cout << m[1][2];        // 42

    // Да можем да събираме, изваждаме, умножаваме и проверяваме за еднаквост матрици
    Matrix m1(4, 4);
    Matrix m2(4, 4);
    Matrix m3;
    cout << (m1 == m2);
    // m3 = m1 + m2;
    // m3 = m1 - m2;
    // m3 = m1 * m2;

    // Много лесно може да попаднем в невалидна ситуация при създаването или присвояването на матрица
    // - напр. ако подадем отрицателни размери на конструктора или съберем матрици с различни размери
    // За това ще е удобно да имаме константа невалидна (null) матрица, която да конструираме или връщаме в такива случаи,
    // както и метод is_null_matrix, който да проверява дали матрица е невалидна.
    // Две невалидни матрици трябва да бъдат считани за "равни"
    Matrix m4(-2, -3);
    cout << m4.is_null_matrix();        // 1 (т.е. true)

    Matrix m5 = Matrix(5, 6) + Matrix(7, 8);
    cout << m5.is_null_matrix();        // 1

    cout << (m4 == m5);                 // 1
    
Отново е част от задачата да решите какви член-данни и типове да използвате, както и да има канонични методи
