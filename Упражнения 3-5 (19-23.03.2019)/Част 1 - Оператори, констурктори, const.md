## Const

### Задача 1.
Във всеки от класовете, сложете const зад всеки метод, който не променя обекта.

Всеки гетър, който връща указател към масив, да връща не обикновен указател, а указател към константа

## Оператори

Прочетете [за операторите](https://github.com/Scorpion333/fmi-textbook/blob/master/Оператори.md), ако не сте.

### Задача 2.
Променете следните функции в
[кода за магазина](https://github.com/fmi-lab/oop-2019-kn-group1-sem/blob/master/Упражнение%202%20(06.03.2019)/Решение.cpp),
така че станат оператори:

- sum_of_costs да стане оператор +
- add_product да стане оператор +=
- add_user също да стане оператор += (Не е проблем да имаме две функции с едно и също име, ако приемат различни аргументи)

Променете и main функцията, така че да се компилира (там сега се ползват add_product и add_user)

Какво ще се промени, ако вместо *Cost a, Cost b* напишем *Cost& a, Cost& b*?

А ако напишем *const Cost& а, const Cost& b*?

Има ли смисъл да пишем *const int& _lv*? Защо?

### Задача 3.
Напишете като външни функции:
- оператор ==(const Cost& a, const Cost& b), който приема две цени и връща дали първата е равна на втората
- оператор < (const Cost& a, const Cost& b) и оператор > (const Cost& a, const Cost& b)
- оператор * (const Cost& c, int n), който приема цена и цяло число и връща цена, равна на старата, умножена по числото

### Задача 4.
Напишете като методи на Cost:
- оператор += (int added_lv), който добавя числото към левовете на цената
- оператор += (const Cost& other), който добавя подадената цена към нашата

### Задача 5.
За всеки от класовете напишете оператор= като метод, приемащ един аргумент от тип const Класа&.
Методът да прави нашия обект равен на другия, т.е. със същите стойности на член-данните

Spoiler alert: За масивите ще е по-сложно (но и преди сте копирали масиви)

## Конструктор за копиране

### Задача 6.
За всеки от класовете напишете
[Конструктор за копиране](https://github.com/Scorpion333/fmi-textbook/blob/master/Конструктори.md#конструктор-за-копиране)
