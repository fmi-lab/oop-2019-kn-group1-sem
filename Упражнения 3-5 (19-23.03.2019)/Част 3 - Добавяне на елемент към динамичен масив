## Добавяне на елемент към масив, заделен в динамичната памет

### Задача 1.
Напишете функция add_element(double*& arr, int size, double element), която "добавя елемент"
към масива arr като насочва arr към нов масив, съдържащ старите елементи и новия елемент.

Защо arr е double*& ?

### Задача 2.
Студентът във ФМИ Митко Вегана има домашно по ПОП (Първобитно и остаряло програмиране), в което често му
трябва да добавя елемент към масив. Не му хареса обаче да използва add_element, понеже се сети, че ако
всеки път се заделя нова памет и се копират всички стари елементи, програмата ще работи много бавно.
Затова му хрумна, че може да направи така:

- Ще заделя за всеки масив памет, кратна на 10 - така ако в един масив има записани 17 елемента, Митко ще знае,
че има място за 20 елемента (т.е. за още 3), а ако има 42 елемента, ще знае, че има памет за 50 (т.е. още 8)
- При добавяне на елемент към някой масив, ако size се дели на 10, ще се заделя нова памет
(с място за 10 елемента повече) и в нея ще се копират стариете елементи, както в add_element
- Ако пък size не се дели на 10, няма да се заделя памет (защото ще има място),
просто елементът ще се запише на първата свободна позиция

Митко реши да напише функция fast_add_element, която да е подобна на add_element, но да следва горната логика с делението на 10.

За жалост вчера Митко си нарани ръката на турнир по канадска борба и затова помоли колегата си Пепи да напише функцията вместо
него (типично в свой стил, Пепи реши, че не му се занимава и ще влачи ПОП, но не отказа помощ на колегата в беда).
Пепи обаче е зает тази седмица, понеже трябва да подготвя зай..., пардон, първокурсниците
си за тяхното контролно по ООП. Ето защо той ви моли вие да напишете функцията fast_add_element<br>
и да убиете с един код две зайчета - хем да му спестите време, хем да упражните уменията си по динамична памет

### Задача 3.
Митко и Пепи имат колежка - Стела, която измисли друга идея за домашното по ПОП:

- Ще заделя за всеки масив памет с размер степен на 2 - 2, 4, 8, 16, 32, ...
Така ако в един масив има записани 17 елемента, тя ще знае, че има място за 32 елемента
(т.е. за още 15), а ако има 42 елемента, ще знае, че има памет за 64 (т.е. още 22)
- При добавяне на елемент към някой масив, ако size е степен на 2, ще се заделя нова памет
(с два пъти повече място) и в нея ще се копират старите елементи, както в add_element
- Ако пък size не е степен на 2, няма да се заделя памет (защото ще има място),
просто елементът ще се запише на първата свободна позиция

На Стела често ѝ хрумват гениални идеи като тази (забележете, че тя ще заделя нова памет доста по-рядко от Митко),
но пък тя обича да се захваща с много неща и все оставя нещо несвършено. Така стана и тази седмица -
отиде на ски лагер, преди да напише своята "бърза" функция - quick_add_element, която добява елемент,
следвайки логиката със степените на 2.

По пътя към планината обаче се сети да се обади на услужливия си колега Пепи, който отново реши да ви помогне да
упражните динамичните масиви с тази задача

### Задача 4.

> Забележка: В тази и следващата задача се иска двата масива в Store да се управляват по два различни начина.
По принцип смесването на двете идеи е лоша практика - и занапред ще правим динамични масиви само по метода с удвояването
на паметта. Но за целите на упражнението е добре да реализирате разширяващ се масив и по двата начина

Променете класа Store така, че масивът от продукти да е заделени в динамичната памет:
- конструкторът по подразбиране трябва да създава празен, но валиден масив
- в конструктора за копиране трябва да заделите памет, достатъчна за да копирате other.products
- операторът = ще е доста подобен на копи конструктора, но в него трябва да изтриете products, преди да
заделите новата памет
- трябва да има и деструктор
- добавянето на продукт и разширяването на products да стават по метода на Митко
(имайки предвид това, колко памет трябва да заделяте в конструкторите?)

Добра идея е да добавите една нова член-данна - capacity_of_products, в която да пазите колко памет
е заделена към момента за масива. Така вместо да проверявате дали number_of_products се дали на 10,
ще проверявате дали number_of_products == capacity_of_products.

Сигурно не звучи кой знае какво, но освен по-добре изглеждащата проверка, има още поне едно предимство
да използвате капицитет.

Сещате ли се какво е то? (Жокер: const Store& other)

### Задача 5.
Променете класа Store така, че масивът от потребители да е заделен в динамичната памет:
- конструкторът по подразбиране трябва да създава празен, но валиден масив
- в конструктора за копиране трябва да заделите памет, достатъчна за да копирате other.user
- в деструктора и оператора = също трябва да се добавят 1-2 реда
- добавянето на потребител и разширяването на users да стават по метода на Стела
(имайки предвид това, колко памет трябва да заделяте в конструкторите?)

Отново е добра идея да пазите в нова променлива капацитета на users. И вместо да проверявате дали
number_of_users е степен на 2, да проверявате дали number_of_users == capacity_of_users
